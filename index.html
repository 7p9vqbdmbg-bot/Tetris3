<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>–¢–µ—Ç—Ä–∏—Å –¥–ª—è –º–æ–±–∏–ª—å–Ω–æ–≥–æ –∏ –ü–ö</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body { display: flex; flex-direction: column; align-items: center; margin: 0; background: #222; color: #eee; font-family: monospace; }
  #game { background: #000; border: 2px solid #444;
    width: 90vw; max-width: 400px; height: 160vw; max-height: 800px;}
  .controls {
    display: flex; flex-wrap: wrap; justify-content: center; gap: 16px;
    margin-top: 10px;
  }
  .controls button {
    font-size: 2em; padding: 18px; border-radius: 14px; border: 2px solid #555;
    background: #444; color: #eee; margin-bottom: 8px; touch-action: manipulation;
  }
</style>
</head>
<body>
<canvas id="game" width="200" height="400"></canvas>
<div class="controls">
  <button onclick="moveLeft()" ontouchstart="moveLeft()">‚óÄÔ∏è</button>
  <button onclick="rotate()" ontouchstart="rotate()">üîÑ</button>
  <button onclick="moveRight()" ontouchstart="moveRight()">‚ñ∂Ô∏è</button>
  <button onclick="moveDown()" ontouchstart="moveDown()">‚è¨</button>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ROWS = 20, COLS = 10, BLOCK_SIZE = canvas.width / COLS;

const COLORS = [ null,'cyan','blue','orange','yellow','green','purple','red'];
const SHAPES = [
  [], [[1,1,1,1]], [[2,0,0],[2,2,2]], [[0,0,3],[3,3,3]], [[4,4],[4,4]],
  [[0,5,5],[5,5,0]], [[0,6,0],[6,6,6]], [[7,7,0],[0,7,7]]
];

function createMatrix(rows, cols) {
  const matrix = [];
  while (rows--) matrix.push(new Array(cols).fill(0));
  return matrix;
}
const board = createMatrix(ROWS, COLS);
const player = { pos: {x: 3, y: 0}, matrix: SHAPES[1] };

function drawBlock(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  ctx.strokeStyle = '#222';
  ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
}
function drawMatrix(matrix, offset) {
  matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        drawBlock(x + offset.x, y + offset.y, COLORS[value]);
      }
    });
  });
}
function playerDrop() {
  player.pos.y++;
  if (collide(board, player)) {
    player.pos.y--;
    merge(board, player);
    playerReset();
  }
  dropCounter = 0;
}
function collide(board, player) {
  const m = player.matrix;
  const o = player.pos;
  for (let y = 0; y < m.length; y++) {
    for (let x = 0; x < m[y].length; x++) {
      if (m[y][x] !== 0 &&
         (board[y + o.y] &&
          board[y + o.y][x + o.x]) !== 0) {
        return true;
      }
    }
  }
  return false;
}
function merge(board, player) {
  player.matrix.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        board[y + player.pos.y][x + player.pos.x] = value;
      }
    });
  });
}
function playerReset() {
  const pieces = 'TJLOSZI';
  const index = pieces.length * Math.random() | 0;
  player.matrix = SHAPES[index + 1];
  player.pos.y = 0;
  player.pos.x = 3;
  if (collide(board, player)) {
    alert('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞');
    board.forEach(row => row.fill(0));
  }
}
function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawMatrix(board, {x: 0, y: 0});
  drawMatrix(player.matrix, player.pos);
}

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
function update(time = 0) {
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;
  if (dropCounter > dropInterval) {
    playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

// –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö –∏ –¥–µ—Å–∫—Ç–æ–ø–∞
window.moveLeft = function() {
  player.pos.x--;
  if (collide(board, player)) player.pos.x++;
};
window.moveRight = function() {
  player.pos.x++;
  if (collide(board, player)) player.pos.x--;
};
window.moveDown = function() {
  playerDrop();
};
// –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–≤–æ—Ä–æ—Ç–∞ —Å "wall kick"
window.rotate = function() {
  const oldMatrix = player.matrix;
  const oldX = player.pos.x;
  player.matrix = rotate(player.matrix);

  let offset = 1;
  while (collide(board, player)) {
    player.pos.x += offset;
    offset = -(offset + (offset > 0 ? 1 : -1));
    if (Math.abs(offset) > player.matrix[0].length) {
      player.matrix = oldMatrix;
      player.pos.x = oldX;
      break;
    }
  }
};

// –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å—Ç—Ä–µ–ª–æ–∫ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞
document.addEventListener('keydown', event => {
  if (event.key === 'ArrowLeft') window.moveLeft();
  else if (event.key === 'ArrowRight') window.moveRight();
  else if (event.key === 'ArrowDown') window.moveDown();
  else if (event.key === 'ArrowUp') window.rotate();
});

function rotate(matrix, reverse = false) {
  const m = matrix;
  const N = m.length;
  const result = createMatrix(N, N);
  for (let y = 0; y < N; y++) {
    for (let x = 0; x < N; x++) {
      if (!reverse) result[x][N - 1 - y] = m[y][x];
      else result[N - 1 - x][y] = m[y][x];
    }
  }
  return result;
}

update();
</script>
</body>
</html>
